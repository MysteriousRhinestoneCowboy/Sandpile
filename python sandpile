import tkinter as tk
from tkinter import *
import random
import tkcolorpicker
from tkcolorpicker import askcolor


class Grid:
    def __init__(self, root, size, width, height, shape="square", borderWidth=1.0, border="lightgray", fill="white",
                 activefill="darkgray", cellData=[], borderData=[]):
        self.sin60 = 3 ** 0.5 / 2
        self.root = root
# Distance between the center of two cells
        self.size = size
        self.width = width
        self.height = height
        self.shape = shape
        self.border = border
        self.borderWidth = borderWidth
        self.fill = fill
        self.activefill = activefill
        self.cells = {}
        self.cellData = cellData
        self.borders = {}
        self.borderData = borderData

        self.grid = Canvas(self.root, height=self.height, width=self.width)
        '''self.grid.bind("<Button-1>", self.command1)
        self.grid.bind("<Button-2>", self.command2)'''
        self.grid.bind("<Button-3>", self.command3)

        if self.shape == "square":
            self.cardinals = ((0, 1), (1, 0), (-1, 0), (0, -1))
            self.createSquare()

        elif self.shape == "hex":
            self.cardinals = ((0, 1), (1, 0), (1, 1), (0, -1), (-1, 0), (-1, -1))
            self.createHex()

        elif self.shape == "tri":
            self.cardinals = ((0, -1), (1, 0), (0, 0))
            self.createTri()

        elif self.shape == "moore":
            self.cardinals = ((1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0))
            self.createSquare()

        elif self.shape == "right":
            self.cardinals = ((0, 1), (-1, 0), (0, 0))
            self.createRight()

        for border in self.borders:
            self.grid.tag_raise(border)

    def createSquare(self):
        self.transform = ((1, 0), (0, 1))
        sideLength = self.size

        self.iCount = self.width // self.size
        self.jCount = self.height // self.size

        self.cellTemplate = (0, 0, self.size, 0, self.size, -1 * self.size, 0, -1 * self.size)

        for i in range(self.iCount):
            for j in range(self.jCount):
                x = i * self.size
                y = self.height - self.size * j
                cell = "{}.{}".format(str(i), str(j))
                center = (x, y)
                self.grid.create_polygon(self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                         self.cellTemplate[2] + x, self.cellTemplate[3] + y,
                                         self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                         self.cellTemplate[6] + x, self.cellTemplate[7] + y,
                                         fill=self.fill, activefill=self.activefill, outline=self.border, tags=cell)
                self.cells[cell] = self.cellData
                textCenter = (x + self.size / 2, y - self.size / 2)
                self.grid.create_text(textCenter[0], textCenter[1], text=self.cells[cell], tags="{}.text".format(cell))

                bordertag0 = "{}.{}.{}".format(cell, str(i + 1), str(j))
                self.grid.create_line(self.cellTemplate[2] + x, self.cellTemplate[3] + y,
                                      self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                      fill=self.border, width=self.borderWidth, tags=bordertag0)
                self.borders[bordertag0] = self.borderData

                bordertag1 = "{}.{}.{}".format(cell, str(i), str(j + 1))
                self.grid.create_line(self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                      self.cellTemplate[6] + x, self.cellTemplate[7] + y,
                                      fill=self.border, width=self.borderWidth, tags=bordertag1)
                self.borders[bordertag1] = self.borderData

                if i == 0:
                    bordertagj = "{}.-1.{}".format(str(i), cell)
                    self.grid.create_line(self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                          self.cellTemplate[2] + x, self.cellTemplate[3] + y,
                                          fill=self.border, width=self.borderWidth, tags=bordertagj)
                    self.borders[bordertagj] = self.borderData

                if j == 0:
                    bordertagi = "-1.{}.{}".format(str(j), cell)
                    self.grid.create_line(self.cellTemplate[6] + x, self.cellTemplate[7] + y,
                                          self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                          fill=self.border, width=self.borderWidth, tags=bordertagi)
                    self.borders[bordertagi] = self.borderData

    def createRight(self):
        self.transform = ((1, 0), (0, 1))
        sideLength = self.size

        self.iCount = self.width // self.size
        self.jCount = self.height // self.size

        self.cellTemplate = (0, 0, self.size, 0, self.size, -1 * self.size, 0, -1 * self.size)

        for i in range(self.iCount):
            for j in range(self.jCount):
                x = i * self.size
                y = self.height - self.size * j
                cellUp = "{}.{}.1".format(str(i), str(j))
                cellDown = "{}.{}.-1".format(str(i), str(j))
                center = (x, y)
                self.grid.create_polygon(self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                         self.cellTemplate[2] + x, self.cellTemplate[3] + y,
                                         self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                         fill=self.fill, activefill=self.activefill, outline=self.border, tags=cellDown)
                self.grid.create_polygon(self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                         self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                         self.cellTemplate[6] + x, self.cellTemplate[7] + y,
                                         fill=self.fill, activefill=self.activefill, outline=self.border, tags=cellUp)
                self.cells[cellUp] = self.cellData
                self.cells[cellDown] = self.cellData

                '''textCenter = (x + self.size / 2, y - self.size / 2)
                self.grid.create_text(textCenter[0], textCenter[1], text=cell)'''

                bordertag0 = "{}.{}.{}.{}".format(str(i), str(j), str(i), str(j))
                self.grid.create_line(self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                      self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                      fill=self.border, width=self.borderWidth, tags=bordertag0)
                self.borders[bordertag0] = self.borderData

                bordertag1 = "{}.{}.{}.{}".format(str(i), str(j), str(i + 1), str(j))
                self.grid.create_line(self.cellTemplate[2] + x, self.cellTemplate[3] + y,
                                      self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                      fill=self.border, width=self.borderWidth, tags=bordertag1)
                self.borders[bordertag1] = self.borderData

                bordertag2 = "{}.{}.{}.{}".format(str(i), str(j + 1), str(i), str(j))
                self.grid.create_line(self.cellTemplate[4] + x, self.cellTemplate[5] + y,
                                      self.cellTemplate[6] + x, self.cellTemplate[7] + y,
                                      fill=self.border, width=self.borderWidth, tags=bordertag2)
                self.borders[bordertag2] = self.borderData

                if j == 0:
                    bordertagj = "-1.{}.{}.{}".format(str(j), str(i), str(j))
                    self.grid.create_line(self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                          self.cellTemplate[2] + x, self.cellTemplate[3] + y,
                                          fill="black", width=self.borderWidth, tags=bordertagj)
                    self.borders[bordertagj] = self.borderData

                if i == 0:
                    bordertagi = "{}.{}.{}.-1".format(str(i), str(j), str(i))
                    self.grid.create_line(self.cellTemplate[6] + x, self.cellTemplate[7] + y,
                                          self.cellTemplate[0] + x, self.cellTemplate[1] + y,
                                          fill="black", width=self.borderWidth, tags=bordertagi)
                    self.borders[bordertagi] = self.borderData

    def createHex(self):
        self.transform = ((1, -0.5), (0, self.sin60))
        sideLength = self.size / 3 ** 0.5

        self.iCount = int(self.width / self.size)
        self.jCount = int(self.height / sideLength / 1.5 + 1)

        self.cellTemplate = (0, 0, 0, -1 * sideLength, self.size / 2, -1.5 * sideLength,
                             self.size, -1 * sideLength, self.size, 0, self.size / 2, 0.5 * sideLength)

        for j in range(self.jCount):
            offset = j // 2
            for i in range(1 * offset, self.iCount + offset):
                x = i * self.size
                y = self.height - self.size * j
                cell = "{}.{}".format(str(i), str(j))
                center = (x * self.transform[0][0] + self.size * j * self.transform[0][1],
                          self.height - x * self.transform[1][0] - self.size * j * self.transform[1][1])
                self.grid.create_polygon(self.cellTemplate[0] + center[0], self.cellTemplate[1] + center[1],
                                         self.cellTemplate[2] + center[0], self.cellTemplate[3] + center[1],
                                         self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                         self.cellTemplate[6] + center[0], self.cellTemplate[7] + center[1],
                                         self.cellTemplate[8] + center[0], self.cellTemplate[9] + center[1],
                                         self.cellTemplate[10] + center[0], self.cellTemplate[11] + center[1],
                                         fill=self.fill, activefill=self.activefill, outline=None, tags=cell)
                self.cells[cell] = self.cellData
                textCenter = (center[0] + self.size / 2, center[1] - sideLength / 2)
                self.grid.create_text(textCenter[0], textCenter[1], text=self.cells[cell], tags="{}.text".format(cell))

                bordertag0 = "{}.{}.{}".format(cell, str(i), str(j + 1))
                self.grid.create_line(self.cellTemplate[2] + center[0], self.cellTemplate[3] + center[1],
                                      self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                      fill=self.border, width=self.borderWidth, tags=bordertag0)
                self.borders[bordertag0] = self.borderData

                bordertag1 = "{}.{}.{}".format(cell, str(i + 1), str(j + 1))
                self.grid.create_line(self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                      self.cellTemplate[6] + center[0], self.cellTemplate[7] + center[1],
                                      fill=self.border, width=self.borderWidth, tags=bordertag1)
                self.borders[bordertag1] = self.borderData

                bordertag2 = "{}.{}.{}".format(cell, str(i + 1), str(j))
                self.grid.create_line(self.cellTemplate[6] + center[0], self.cellTemplate[7] + center[1],
                                      self.cellTemplate[8] + center[0], self.cellTemplate[9] + center[1],
                                      fill=self.border, width=self.borderWidth, tags=bordertag2)
                self.borders[bordertag2] = self.borderData

    def createTri(self):
        self.transform = ((1, -0.5), (0, self.sin60))
        sideLength = self.size

        self.iCount = int(self.width / sideLength + 1.99)
        self.jCount = int(self.height / sideLength / self.sin60  + 0.99)

        self.cellTemplate = (0, 0, sideLength, 0, 0.5 * sideLength, -1 * self.sin60 * sideLength, -0.5 * sideLength, -1 * self.sin60 * sideLength)

        for j in range(self.jCount):
            offset = j // 2
            for i in range(1 * offset, self.iCount + offset):
                x = i * self.size
                y = self.height - self.size * j
                cellUp = "{}.{}.1".format(str(i), str(j))
                cellDown = "{}.{}.-1".format(str(i), str(j))
                center = (x * self.transform[0][0] + self.size * j * self.transform[0][1],
                          self.height - x * self.transform[1][0] - self.size * j * self.transform[1][1])
                self.grid.create_polygon(self.cellTemplate[0] + center[0], self.cellTemplate[1] + center[1],
                                         self.cellTemplate[2] + center[0], self.cellTemplate[3] + center[1],
                                         self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                         fill=self.fill, activefill=self.activefill, outline=None, tags=cellUp)
                self.grid.create_polygon(self.cellTemplate[0] + center[0], self.cellTemplate[1] + center[1],
                                         self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                         self.cellTemplate[6] + center[0], self.cellTemplate[7] + center[1],
                                         fill=self.fill, activefill=self.activefill, outline=None, tags=cellDown)
                self.cells[cellUp] = self.cellData
                self.cells[cellDown] = self.cellData
                '''textCenter = (center[0] + 0.25 * sideLength, center[1] + -0.5 * self.sin60 * sideLength)
                self.grid.create_text(textCenter[0], textCenter[1], text=cellUp[:-1])'''

                bordertag0 = "{}.{}.{}.{}".format(str(i), str(j), str(i), str(j))
                self.grid.create_line(self.cellTemplate[0] + center[0], self.cellTemplate[1] + center[1],
                                      self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                      fill=self.border, width=self.borderWidth, tags=bordertag0)
                self.borders[bordertag0] = self.borderData

                bordertag1 = "{}.{}.{}.{}".format(str(i), str(j), str(i), str(j + 1))
                self.grid.create_line(self.cellTemplate[4] + center[0], self.cellTemplate[5] + center[1],
                                      self.cellTemplate[6] + center[0], self.cellTemplate[7] + center[1],
                                      fill=self.border, width=self.borderWidth, tags=bordertag1)
                self.borders[bordertag1] = self.borderData

                bordertag2 = "{}.{}.{}.{}".format(str(i), str(j), str(i - 1), str(j))
                self.grid.create_line(self.cellTemplate[0] + center[0], self.cellTemplate[1] + center[1],
                                      self.cellTemplate[6] + center[0], self.cellTemplate[7] + center[1],
                                      fill=self.border, width=self.borderWidth, tags=bordertag2)
                self.borders[bordertag2] = self.borderData

    def command1(self, event):
        pass

    def command2(self, event):
        pass

    def command3(self, event):
        tag = self.getCurrent()
        if tag in self.cells:
            print(tag, self.cells[tag])
        else:
            print(tag)

    def getBordering(self, border):
        coords = border.split(".")
        if self.shape == "tri" or self.shape == "right":
            cell0 = "{}.{}.-1".format(coords[0], coords[1])
            cell1 = "{}.{}.1".format(coords[2], coords[3])
        else:
            cell0 = "{}.{}".format(coords[0], coords[1])
            cell1 = "{}.{}".format(coords[2], coords[3])
        cells = (cell0, cell1)
        return(cells)

    def getCurrent(self):
        try:
            tag = self.grid.gettags(CURRENT)[0]
            '''height = self.cells[tag]'''
            return tag
        except:
            print("tag not found")
            return None

    def getInt(self, cell):
        cellLst = cell.split(".")
        if self.shape == "tri" or self.shape == "right":
            cellInt = (int(cellLst[0]), int(cellLst[1]), int(cellLst[2]))
        else:
            cellInt = (int(cellLst[0]), int(cellLst[1]))
        return cellInt

    def getNeighbors(self, cell):
        neighbors = []
        cellInt = self.getInt(cell)

        if self.shape == "tri" or self.shape == "right":
            for direction in self.cardinals:
                cellString = "{}.{}.{}".format(str(cellInt[0] + direction[0] * cellInt[2]),
                                               str(cellInt[1] + direction[1] * cellInt[2]),
                                               str(cellInt[2] * -1))
                neighbors.append(cellString)

        else:
            for direction in self.cardinals:
                cellString = "{}.{}".format(str(cellInt[0] + direction[0]), str(cellInt[1] + direction[1]))
                neighbors.append(cellString)
        return neighbors

    def randomHeight(self, maxHeight=3):
        for cell in self.cells:
            randomHeight = random.randint(0, maxHeight)
            self.cells[cell] = randomHeight

    def randomCell(self):
        pass

    def showTopography(self, interval=1):
        for border in self.borders:
            cell = self.getBordering(border)
            try:
                height0 = self.cells[cell[0]] // interval * interval
                height1 = self.cells[cell[1]] // interval * interval
                if height0 != height1:
                    self.grid.itemconfig(border, width=3, fill="black")
            except:
                pass

    def updateFill(self, cell, color):
        self.grid.itemconfig(cell, fill=color)

    def updateText(self, cell, color, text):
        tag = "{}.text".format(cell)
        self.grid.itemconfig(tag, fill=color, text=str(text))


class Addend:
    def __init__(self, parent, width, height, colors, shape, speed, penSize, stamp, scalar, size, pile):
        self.root = Toplevel(parent)
        geoDim = "{}x{}".format(str(width + 130), str(height))
        self.root.geometry(geoDim)
        self.root.title("Addend")

        self.colors = colors[:]
        self.shape = shape
        self.speed = speed
        self.penSize = penSize
        self.stamp = stamp
        self.scalar = scalar
        self.width = width
        self.height = height
        self.size = size
        self.addend = {}
        self.combine = True

        self.updatePile()
        for cell in self.pile.cells:
            self.pile.cells[cell] = pile[cell]
            self.updateCell(cell)

        self.updateColor()

        self.menuFrame = Frame(self.root, width=120, height=height-200)
        self.menuFrame.grid(row=1, column=1)
        self.menuFrame.pack_propagate(0)

        self.penButton = Button(self.menuFrame, text="Pen Size {}".format(str(self.penSize)), command=self.changePen)
        self.penButton.pack(side=TOP, fill=X)
        self.penButton.bind("<ButtonRelease-2>", self.setPen)

        self.textButton = Button(self.menuFrame, text="Hide Text", command=self.textShow)
        self.textButton.pack(side=TOP, fill=X)

        Frame(self.menuFrame, height=25).pack(side=TOP)

        self.identityButton = Button(self.menuFrame, text="Add Identity", command=self.addIdentity)
        self.identityButton.pack(side=TOP, fill=X)

        self.inverseButton = Button(self.menuFrame, text="Invert", command=self.getInverse)
        self.inverseButton.pack(side=TOP, fill=X)

        self.conjugateButton = Button(self.menuFrame, text="Conjugate", command=self.getConjugate)
        self.conjugateButton.pack(side=TOP, fill=X)

        self.stampButton = Button(self.menuFrame, text="Add {}".format(str(self.stamp)), command=self.addStamp)
        self.stampButton.pack(side=TOP, fill=X)
        self.stampButton.bind("<ButtonRelease-2>", self.setStamp)

        self.scalarButton = Button(self.menuFrame, text="Multiply by {}".format(str(self.scalar)), command=self.multiplyScalar)
        self.scalarButton.pack(side=TOP, fill=X)
        self.scalarButton.bind("<ButtonRelease-2>", self.setScalar)

        Frame(self.menuFrame, height=25).pack(side=TOP)

        self.generationButton = Button(self.menuFrame, text="Generation", command=self.generation)
        self.generationButton.pack(side=TOP, fill=X)
        self.generationButton.bind("<ButtonRelease-2>", self.generationCount)

        self.collapseButton = Button(self.menuFrame, text="Collapse", command=self.startCollapse)
        self.collapseButton.pack(fill=X)
        self.collapseButton.bind("<ButtonRelease-2>", self.setSpeed)

        Frame(self.menuFrame, height=10).pack(side=TOP)

        self.resetButton = Button(self.menuFrame, text="Reset", command=self.reset)
        self.resetButton.pack(side=TOP, fill=X)

        self.addButton = Button(self.menuFrame, text="Destroy Addend", command=self.addSandpiles)
        self.addButton.pack(side=TOP, fill=X)

        parent.wait_window(self.root)

    def addSandpiles(self):
        add = AddDialogue(self.root, self.combine).get()
        if add == True:
            self.addend = self.pile.cells
        self.root.destroy()

    def updatePile(self):
        self.pile = Grid(self.root, self.size, self.width, self.height, activefill=None, cellData=0, shape=self.shape)
        self.pile.grid.grid(row=0, column=0, rowspan=2)
        self.pile.grid.bind("<ButtonRelease-1>", self.addPen)
        self.pile.grid.bind("<ButtonRelease-2>", self.setCell)
        self.neighbors = len(self.pile.cardinals)

        inverse = {}
        for cell in self.pile.cells:
            inverse[cell] = 2 * self.neighbors - 2
        collapsedInverse = self.instaCollapse(inverse)
        self.inverseCore = self.conjugate(collapsedInverse)
        identityCore = {}
        for cell in self.inverseCore:
            identityCore[cell] = self.inverseCore[cell] + self.neighbors - 1
        self.identity = self.instaCollapse(identityCore)
        self.text = True

    def updateColor(self):
        self.colorFrame = Frame(self.root, width=120, height=220)
        self.colorFrame.pack_propagate(0)
        self.colorFrame.grid(row=0, column=1)
        self.colorFrame.bind("<ButtonRelease-2>", self.setColors)
        for rank in range(self.neighbors):
            colorLabel = Label(self.colorFrame, bg=self.colors[rank][0], fg=self.colors[rank][1], text=str(rank))
            colorLabel.pack(fill=X)
            colorLabel.bind("<ButtonRelease-2>", self.setColors)
        colorLabel = Label(self.colorFrame, bg=self.colors[-1][0], fg=self.colors[-1][1], text="{}+".format(str(self.neighbors)))
        colorLabel.pack(fill=X)
        colorLabel.bind("<ButtonRelease-2>", self.setColors)

    def setColors(self, event=None):
        colorChoose = ColorSetter(self.root, self.colors, self.neighbors).get()
        self.colors = colorChoose[:]
        self.colorFrame.destroy()

        self.updateColor()
        for cell in self.pile.cells:
            self.updateCell(cell)

    def setSpeed(self, event=None):
        self.speed = EntryDialogue(self.root, prompt="Choose the speed of collapse in milliseconds", title="Set Speed", oldValue=self.speed).get()

    def addPen(self, event=None):
        tag = self.pile.getCurrent()
        if tag in self.pile.cells:
            self.pile.cells[tag] += self.penSize
            self.updateCell(tag)

    def textShow(self):
        if self.text == True:
            self.text = False
            for cell in self.pile.cells:
                tag = "{}.text".format(cell)
                self.pile.grid.itemconfig(tag, state=HIDDEN)
            self.textButton.config(text="Show Text")
        elif self.text == False:
            self.text = True
            for cell in self.pile.cells:
                tag = "{}.text".format(cell)
                self.pile.grid.itemconfig(tag, state=NORMAL)
            self.textButton.config(text="Hide Text")

    def changePen(self):
        if self.penSize < 0 or self.penSize >= self.neighbors:
            self.penSize = 1
        else:
            self.penSize = self.penSize + 1
        self.penButton.config(text="Pen Size {}".format(str(self.penSize)))

    def setPen(self, event=None):
        value = EntryDialogue(self.root, prompt="Enter the new pen size", title="Set Pen Size", oldValue=self.penSize).get()
        self.penSize = value
        self.penButton.config(text="Pen Size {}".format(str(self.penSize)))

    def startCollapse(self):
        self.collapseButton.config(text="Stop", command=self.stopCollapse)
        self.collapse()

    def collapse(self):
        newGen = self.generation()
        if newGen == True:
            self.collapseTimer = self.pile.grid.after(self.speed, self.collapse)
        else:
            self.collapseButton.config(text="Collapse", command=self.startCollapse)

    def stopCollapse(self):
        self.pile.grid.after_cancel(self.collapseTimer)
        self.collapseButton.config(text="Collapse", command=self.startCollapse)

    def instaCollapse(self, cells={}):
        tooTall = True
        while tooTall == True:
            changes = {}
            for cell in cells:
                if cells[cell] >= self.neighbors:
                    neighbors = self.pile.getNeighbors(cell)
                    for neighbor in neighbors:
                        if neighbor in self.pile.cells:
                            count = changes.get(neighbor, 0) + 1
                            changes[neighbor] = count
                    count = changes.get(cell, 0) - self.neighbors
                    changes[cell] = count
            for cell in changes:
                count = cells.get(cell, 0) + changes[cell]
                cells[cell] = count
            if changes == {}:
                tooTall = False
        return cells

    def conjugate(self, cells={}):
        conjugateCells = {}
        for cell in cells:
            conValue = self.neighbors - 1 - cells[cell]
            value = max(conValue, 0)
            conjugateCells[cell] = value
        return conjugateCells

    def addIdentity(self):
        for cell in self.identity:
            if self.identity[cell] != 0:
                self.pile.cells[cell] += self.identity[cell]
                self.updateCell(cell)

    def addStamp(self):
        for cell in self.pile.cells:
            self.pile.cells[cell] += self.stamp
            self.updateCell(cell)

    def setStamp(self, event=None):
        newStamp = EntryDialogue(self.root, prompt="Enter the new stamp size", title="Set Stamp", oldValue=self.stamp).get()
        self.stamp = newStamp
        self.stampButton.config(text="Add {}".format(str(self.stamp)))

    def multiplyScalar(self):
        for cell in self.pile.cells:
            self.pile.cells[cell] *= self.scalar
            self.updateCell(cell)

    def setScalar(self, event=None):
        newScalar = EntryDialogue(self.root, prompt="Enter the new scalar", title="Set Scalar", oldValue=self.scalar).get()
        self.scalar = newScalar
        self.scalarButton.config(text="Multiply by {}".format(str(self.scalar)))

    def getConjugate(self):
        conjugate = self.conjugate(self.pile.cells)
        self.pile.cells = conjugate
        for cell in self.pile.cells:
            self.updateCell(cell)

    def getInverse(self):
        conjugate = self.conjugate(self.pile.cells)
        for cell in self.pile.cells:
            count = conjugate.get(cell, 0)
            count += self.inverseCore.get(cell, 0)
            count += self.identity[cell]
            conjugate[cell] = count
        self.pile.cells = self.instaCollapse(conjugate)
        for cell in self.pile.cells:
            self.updateCell(cell)


    def generation(self):
        changes = {}
        for cell in self.pile.cells:
            if self.pile.cells[cell] >= self.neighbors:
                neighbors = self.pile.getNeighbors(cell)
                for neighbor in neighbors:
                    if neighbor in self.pile.cells:
                        count = changes.get(neighbor, 0) + 1
                        changes[neighbor] = count
                count = changes.get(cell, 0) - self.neighbors
                changes[cell] = count
        for cell in changes:
            self.pile.cells[cell] += changes[cell]
            self.updateCell(cell)

        if changes == {}:
            return False
        else:
            return True

    def generationCount(self, event=None):
        generation = EntryDialogue(self.root, prompt="How many generations should pass?", title="Set Generations", oldValue=0).get()
        tooTall = True
        while generation > 0 and tooTall == True:
            changes = {}
            for cell in self.pile.cells:
                if self.pile.cells[cell] >= self.neighbors:
                    neighbors = self.pile.getNeighbors(cell)
                    for neighbor in neighbors:
                        if neighbor in self.pile.cells:
                            count = changes.get(neighbor, 0) + 1
                            changes[neighbor] = count
                    count = changes.get(cell, 0) - self.neighbors
                    changes[cell] = count
            for cell in changes:
                self.pile.cells[cell] += changes[cell]
            generation -= 1
            if changes == {}:
                tooTall = False
        for cell in self.pile.cells:
            self.updateCell(cell)

    def setCell(self, event=None):
        tag = self.pile.getCurrent()
        if tag in self.pile.cells:
            value = self.pile.cells[tag]
            newValue = EntryDialogue(self.root, prompt="Enter the new value", oldValue=value, title="Set Cell Value").get()
            self.pile.cells[tag] = newValue
            self.updateCell(tag)

    def updateCell(self, tag):
        if self.pile.cells[tag] < self.neighbors and self.pile.cells[tag] > 0:
            color = self.colors[self.pile.cells[tag]][0]
            textColor = self.colors[self.pile.cells[tag]][1]
        elif self.pile.cells[tag] >= self.neighbors:
            color = self.colors[-1][0]
            textColor = self.colors[-1][1]
        else:
            color = self.colors[0][0]
            textColor = self.colors[0][1]
        self.pile.updateFill(tag, color)
        self.pile.updateText(tag, textColor, self.pile.cells[tag])

    def reset(self):
        confirmation = ConfirmDialogue(self.root, prompt="Are your sure you want to reset the sandpile?", title="Quit").get()
        if confirmation == True:
            for cell in self.pile.cells:
                self.pile.cells[cell] = 0
                self.updateCell(cell)

    def setPile(self, event=None):
        variables = ShapeSetter(self.root, self.shape, self.width, self.height, self.size).get()
        self.pile.grid.destroy()
        self.size = variables[3]
        self.height = variables[2]
        self.width = variables[1]
        self.shape = variables[0]
        self.updatePile()
        self.updateColor()

    def get(self):
        return self.addend


class EntryDialogue:
    def __init__(self, parent, prompt="", oldValue=None, title=None, varType="int"):
        self.value = oldValue
        self.varType = varType
        self.window = Toplevel()

        Label(self.window, text=prompt).pack(fill=X, side=TOP)
        self.window.title(title)

        self.var = StringVar()
        self.var.set(oldValue)
        self.entry = Entry(self.window, textvariable=self.var)
        self.entry.pack(fill=X, side=TOP)

        width = self.window.winfo_reqwidth() // 2

        buttonFrame = Frame(self.window, height=22)
        buttonFrame.pack(fill=X, side=BOTTOM)
        buttonFrame.pack_propagate(0)

        buttonFrameLeft = Frame(buttonFrame, width=width, height=22)
        buttonFrameLeft.pack(side=LEFT)
        buttonFrameLeft.pack_propagate(0)

        buttonFrameRight = Frame(buttonFrame, width=width, height=22)
        buttonFrameRight.pack(side=RIGHT)
        buttonFrameRight.pack_propagate(0)

        Button(buttonFrameLeft, text="OK", command=self.OK, width=width).pack(fill=X)
        Button(buttonFrameRight, text="cancel", command=self.cancel, width=width).pack(fill=X)

        self.entry.bind("<Return>", self.OK)
        self.entry.focus_set()
        self.window.bind("<Escape>", self.cancel)

        parent.wait_window(self.window)

    def cancel(self, event=None):
        self.window.destroy()

    def OK(self, event=None):
        input = self.entry.get()
        if self.varType == "int":
            try:
                self.value = int(input)
                self.window.destroy()
            except:
                pass

        else:
            self.value = input
            self.window.destroy()

    def get(self):
        return self.value


class ConfirmDialogue:
    def __init__(self, parent, prompt="Are you sure?", option="Yes", title=None):
        self.value = False
        self.window = Toplevel()
        self.window.bind("<Escape>", self.cancel)
        self.confirmed = StringVar()
        self.confirmed.set("Cancel")
        self.window.title(title)
        Label(self.window, text=prompt).pack(fill=X, side=TOP)
        Checkbutton(self.window, text=option, variable=self.confirmed, onvalue="Confirm", offvalue="Cancel").pack(side=TOP, anchor=W)
        Button(self.window, textvariable=self.confirmed, command=self.ok).pack(side=TOP)

        parent.wait_window(self.window)

    def cancel(self, event=None):
        self.window.destroy()

    def ok(self):
        value = self.confirmed.get()
        if value == "Confirm":
            self.value = True
        self.window.destroy()

    def get(self):
        return self.value


class AddDialogue:
    def __init__(self, parent, combine):
        self.window = Toplevel(parent)
        self.window.title("Addend Destroy")
        self.window.bind("<Escape>", self.cancel)
        self.window.bind("<Return>", self.ok)
        self.value = combine
        Label(self.window, text="Do you want to add the sandpiles together?").grid(row=0, column=0, columnspan=2)
        self.yon = BooleanVar()
        self.yon.set(combine)
        Radiobutton(self.window, variable=self.yon, text="Yes", value=True).grid(row=1, column=0)
        Radiobutton(self.window, variable=self.yon, text="No", value=False).grid(row=1, column=1)
        Button(self.window, text="OK", command=self.ok, width=8).grid(row=2, column=0)
        Button(self.window, text="cancel", command=self.cancel, width=8).grid(row=2, column=1)

        parent.wait_window(self.window)

    def cancel(self, event=None):
        self.window.destroy()

    def ok(self, event=None):
        self.value = self.yon.get()
        self.window.destroy()

    def get(self):
        return self.value


class Sandpile:
    def __init__(self, width, height):
        self.root = tk.Tk()
        geoDim = "{}x{}".format(str(width + 130), str(height))
        self.root.geometry(geoDim)
        self.root.title("Sandpile")

        self.colors = [["white", "black"],
                       ["red", "black"],
                       ["orange", "black"],
                       ["yellow", "black"],
                       ["green", "black"],
                       ["cyan", "black"],
                       ["indigo", "black"],
                       ["purple", "black"],
                       ["black", "white"]]
        self.shape = "square"
        self.speed = 100
        self.penSize = 1
        self.stamp = 1
        self.scalar = 2
        self.width = width
        self.height = height
        self.size = 40
        self.addend = None

        self.updatePile()

        self.updateColor()

        self.menuFrame = Frame(self.root, width=120, height=height-200)
        self.menuFrame.grid(row=1, column=1)
        self.menuFrame.pack_propagate(0)

        self.penButton = Button(self.menuFrame, text="Pen Size {}".format(str(self.penSize)), command=self.changePen)
        self.penButton.pack(side=TOP, fill=X)
        self.penButton.bind("<ButtonRelease-2>", self.setPen)

        self.textButton = Button(self.menuFrame, text="Hide Text", command=self.textShow)
        self.textButton.pack(side=TOP, fill=X)

        self.addendButton = Button(self.menuFrame, text="New Sandpile", command=self.newPile)
        self.addendButton.pack(side=TOP, fill=X)

        Frame(self.menuFrame, height=25).pack(side=TOP)

        self.identityButton = Button(self.menuFrame, text="Add Identity", command=self.addIdentity)
        self.identityButton.pack(side=TOP, fill=X)

        self.inverseButton = Button(self.menuFrame, text="Invert", command=self.getInverse)
        self.inverseButton.pack(side=TOP, fill=X)

        self.conjugateButton = Button(self.menuFrame, text="Conjugate", command=self.getConjugate)
        self.conjugateButton.pack(side=TOP, fill=X)

        self.stampButton = Button(self.menuFrame, text="Add {}".format(str(self.stamp)), command=self.addStamp)
        self.stampButton.pack(side=TOP, fill=X)
        self.stampButton.bind("<ButtonRelease-2>", self.setStamp)

        self.scalarButton = Button(self.menuFrame, text="Multiply by {}".format(str(self.scalar)), command=self.multiplyScalar)
        self.scalarButton.pack(side=TOP, fill=X)
        self.scalarButton.bind("<ButtonRelease-2>", self.setScalar)

        Frame(self.menuFrame, height=25).pack(side=TOP)

        self.generationButton = Button(self.menuFrame, text="Generation", command=self.generation)
        self.generationButton.pack(side=TOP, fill=X)
        self.generationButton.bind("<ButtonRelease-2>", self.generationCount)

        self.collapseButton = Button(self.menuFrame, text="Collapse", command=self.startCollapse)
        self.collapseButton.pack(fill=X)
        self.collapseButton.bind("<ButtonRelease-2>", self.setSpeed)

        Frame(self.menuFrame, height=10).pack(side=TOP)

        self.resetButton = Button(self.menuFrame, text="Reset", command=self.reset)
        self.resetButton.pack(side=TOP, fill=X)
        self.resetButton.bind("<ButtonRelease-2>", self.setPile)

        self.root = mainloop()

        self.core = (self.width, self.height, self.colors, self.shape, self.speed, self.penSize, self.stamp, self.scalar, self.size, self.pile.cells)
        print(self.core)

    def newPile(self):
        self.addendButton.config(text="Addend", command=self.nothing)
        self.resetButton.bind("<ButtonRelease-2>", self.nothing)
        self.addend = Addend(self.root, self.width, self.height, self.colors, self.shape, self.speed, self.penSize,
                             self.stamp, self.scalar, self.size, self.pile.cells)
        addend = self.addend.get()
        for cell in addend:
            self.pile.cells[cell] += addend[cell]
            self.updateCell(cell)
        self.addendButton.config(text="New Sandpile", command=self.newPile)
        self.resetButton.bind("<ButtonRelease-2>", self.setPile)
        self.addend = None

    def nothing(self, event=None):
        pass

    def updatePile(self):
        self.pile = Grid(self.root, self.size, self.width, self.height, activefill=None, cellData=0, shape=self.shape)
        self.pile.grid.grid(row=0, column=0, rowspan=2)
        self.pile.grid.bind("<ButtonRelease-1>", self.addPen)
        self.pile.grid.bind("<ButtonRelease-2>", self.setCell)
        self.neighbors = len(self.pile.cardinals)

        inverse = {}
        for cell in self.pile.cells:
            inverse[cell] = 2 * self.neighbors - 2
            self.updateCell(cell)
        collapsedInverse = self.instaCollapse(inverse)
        self.inverseCore = self.conjugate(collapsedInverse)
        identityCore = {}
        for cell in self.inverseCore:
            identityCore[cell] = self.inverseCore[cell] + self.neighbors - 1
        self.identity = self.instaCollapse(identityCore)
        self.text = True

    def updateColor(self):
        self.colorFrame = Frame(self.root, width=120, height=220)
        self.colorFrame.pack_propagate(0)
        self.colorFrame.grid(row=0, column=1)
        self.colorFrame.bind("<ButtonRelease-2>", self.setColors)
        for rank in range(self.neighbors):
            colorLabel = Label(self.colorFrame, bg=self.colors[rank][0], fg=self.colors[rank][1], text=str(rank))
            colorLabel.pack(fill=X)
            colorLabel.bind("<ButtonRelease-2>", self.setColors)
        colorLabel = Label(self.colorFrame, bg=self.colors[-1][0], fg=self.colors[-1][1], text="{}+".format(str(self.neighbors)))
        colorLabel.pack(fill=X)
        colorLabel.bind("<ButtonRelease-2>", self.setColors)

    def setColors(self, event=None):
        colorChoose = ColorSetter(self.root, self.colors, self.neighbors).get()
        self.colors = colorChoose[:]
        self.colorFrame.destroy()

        self.updateColor()
        for cell in self.pile.cells:
            self.updateCell(cell)

    def setSpeed(self, event=None):
        self.speed = EntryDialogue(self.root, prompt="Choose the speed of collapse in milliseconds", title="Set Speed", oldValue=self.speed).get()

    def addPen(self, event=None):
        tag = self.pile.getCurrent()
        if tag in self.pile.cells:
            self.pile.cells[tag] += self.penSize
            self.updateCell(tag)

    def textShow(self):
        if self.text == True:
            self.text = False
            for cell in self.pile.cells:
                tag = "{}.text".format(cell)
                self.pile.grid.itemconfig(tag, state=HIDDEN)
            self.textButton.config(text="Show Text")
        elif self.text == False:
            self.text = True
            for cell in self.pile.cells:
                tag = "{}.text".format(cell)
                self.pile.grid.itemconfig(tag, state=NORMAL)
            self.textButton.config(text="Hide Text")

    def changePen(self):
        if self.penSize < 0 or self.penSize >= self.neighbors:
            self.penSize = 1
        else:
            self.penSize = self.penSize + 1
        self.penButton.config(text="Pen Size {}".format(str(self.penSize)))

    def setPen(self, event=None):
        value = EntryDialogue(self.root, prompt="Enter the new pen size", title="Set Pen Size", oldValue=self.penSize).get()
        self.penSize = value
        self.penButton.config(text="Pen Size {}".format(str(self.penSize)))

    def startCollapse(self):
        self.collapseButton.config(text="Stop", command=self.stopCollapse)
        self.collapse()

    def collapse(self):
        newGen = self.generation()
        if newGen == True:
            self.collapseTimer = self.pile.grid.after(self.speed, self.collapse)
        else:
            self.collapseButton.config(text="Collapse", command=self.startCollapse)

    def stopCollapse(self):
        self.pile.grid.after_cancel(self.collapseTimer)
        self.collapseButton.config(text="Collapse", command=self.startCollapse)

    def instaCollapse(self, cells={}):
        tooTall = True
        while tooTall == True:
            changes = {}
            for cell in cells:
                if cells[cell] >= self.neighbors:
                    neighbors = self.pile.getNeighbors(cell)
                    for neighbor in neighbors:
                        if neighbor in self.pile.cells:
                            count = changes.get(neighbor, 0) + 1
                            changes[neighbor] = count
                    count = changes.get(cell, 0) - self.neighbors
                    changes[cell] = count
            for cell in changes:
                count = cells.get(cell, 0) + changes[cell]
                cells[cell] = count
            if changes == {}:
                tooTall = False
        return cells

    def conjugate(self, cells={}):
        conjugateCells = {}
        for cell in cells:
            conValue = self.neighbors - 1 - cells[cell]
            value = max(conValue, 0)
            conjugateCells[cell] = value
        return conjugateCells

    def addIdentity(self):
        for cell in self.identity:
            if self.identity[cell] != 0:
                self.pile.cells[cell] += self.identity[cell]
                self.updateCell(cell)

    def addStamp(self):
        for cell in self.pile.cells:
            self.pile.cells[cell] += self.stamp
            self.updateCell(cell)

    def setStamp(self, event=None):
        newStamp = EntryDialogue(self.root, prompt="Enter the new stamp size", title="Set Stamp", oldValue=self.stamp).get()
        self.stamp = newStamp
        self.stampButton.config(text="Add {}".format(str(self.stamp)))

    def multiplyScalar(self):
        for cell in self.pile.cells:
            self.pile.cells[cell] *= self.scalar
            self.updateCell(cell)

    def setScalar(self, event=None):
        newScalar = EntryDialogue(self.root, prompt="Enter the new scalar", title="Set Scalar", oldValue=self.scalar).get()
        self.scalar = newScalar
        self.scalarButton.config(text="Multiply by {}".format(str(self.scalar)))

    def getConjugate(self):
        conjugate = self.conjugate(self.pile.cells)
        self.pile.cells = conjugate
        for cell in self.pile.cells:
            self.updateCell(cell)

    def getInverse(self):
        conjugate = self.conjugate(self.pile.cells)
        for cell in self.pile.cells:
            count = conjugate.get(cell, 0)
            count += self.inverseCore.get(cell, 0)
            count += self.identity[cell]
            conjugate[cell] = count
        self.pile.cells = self.instaCollapse(conjugate)
        for cell in self.pile.cells:
            self.updateCell(cell)


    def generation(self):
        changes = {}
        for cell in self.pile.cells:
            if self.pile.cells[cell] >= self.neighbors:
                neighbors = self.pile.getNeighbors(cell)
                for neighbor in neighbors:
                    if neighbor in self.pile.cells:
                        count = changes.get(neighbor, 0) + 1
                        changes[neighbor] = count
                count = changes.get(cell, 0) - self.neighbors
                changes[cell] = count
        for cell in changes:
            self.pile.cells[cell] += changes[cell]
            self.updateCell(cell)

        if changes == {}:
            return False
        else:
            return True

    def generationCount(self, event=None):
        generation = EntryDialogue(self.root, prompt="How many generations should pass?", title="Set Generations", oldValue=0).get()
        tooTall = True
        while generation > 0 and tooTall == True:
            changes = {}
            for cell in self.pile.cells:
                if self.pile.cells[cell] >= self.neighbors:
                    neighbors = self.pile.getNeighbors(cell)
                    for neighbor in neighbors:
                        if neighbor in self.pile.cells:
                            count = changes.get(neighbor, 0) + 1
                            changes[neighbor] = count
                    count = changes.get(cell, 0) - self.neighbors
                    changes[cell] = count
            for cell in changes:
                self.pile.cells[cell] += changes[cell]
            generation -= 1
            if changes == {}:
                tooTall = False
        for cell in self.pile.cells:
            self.updateCell(cell)

    def setCell(self, event=None):
        tag = self.pile.getCurrent()
        if tag in self.pile.cells:
            value = self.pile.cells[tag]
            newValue = EntryDialogue(self.root, prompt="Enter the new value", oldValue=value, title="Set Cell Value").get()
            self.pile.cells[tag] = newValue
            self.updateCell(tag)

    def updateCell(self, tag):
        if self.pile.cells[tag] < self.neighbors and self.pile.cells[tag] > 0:
            color = self.colors[self.pile.cells[tag]][0]
            textColor = self.colors[self.pile.cells[tag]][1]
        elif self.pile.cells[tag] >= self.neighbors:
            color = self.colors[-1][0]
            textColor = self.colors[-1][1]
        else:
            color = self.colors[0][0]
            textColor = self.colors[0][1]
        self.pile.updateFill(tag, color)
        self.pile.updateText(tag, textColor, self.pile.cells[tag])

    def reset(self):
        confirmation = ConfirmDialogue(self.root, prompt="Are your sure you want to reset the sandpile?", title="Quit").get()
        if confirmation == True:
            for cell in self.pile.cells:
                self.pile.cells[cell] = 0
                self.updateCell(cell)

    def setPile(self, event=None):
        variables = ShapeSetter(self.root, self.shape, self.width, self.height, self.size).get()
        self.pile.grid.destroy()
        self.size = variables[3]
        self.height = variables[2]
        self.width = variables[1]
        self.shape = variables[0]
        self.updatePile()
        self.updateColor()


class ColorSetter:
    def __init__(self, parent, colors, neighbors):
        self.window = Toplevel(parent)
        self.window.title("Colors")
        self.window.bind("<Escape>", self.cancel)
        self.window.bind("<Return>", self.OK)
        self.neighbors = neighbors
        self.colors = colors
        self.values = colors[:]

        self.label0 = ""
        self.label1 = ""
        self.label2 = ""
        self.label3 = ""
        self.label4 = ""
        self.label5 = ""
        self.label6 = ""
        self.label7 = ""
        self.label8 = ""
        self.labels = [self.label0,
                       self.label1,
                       self.label2,
                       self.label3,
                       self.label4,
                       self.label5,
                       self.label6,
                       self.label7,
                       self.label8]

        self.cell0 = ""
        self.cell1 = ""
        self.cell2 = ""
        self.cell3 = ""
        self.cell4 = ""
        self.cell5 = ""
        self.cell6 = ""
        self.cell7 = ""
        self.cell8 = ""
        self.cells = [self.cell0,
                      self.cell1,
                      self.cell2,
                      self.cell3,
                      self.cell4,
                      self.cell5,
                      self.cell6,
                      self.cell7,
                      self.cell8]

        self.text0 = ""
        self.text1 = ""
        self.text2 = ""
        self.text3 = ""
        self.text4 = ""
        self.text5 = ""
        self.text6 = ""
        self.text7 = ""
        self.text8 = ""
        self.texts = [self.text0,
                      self.text1,
                      self.text2,
                      self.text3,
                      self.text4,
                      self.text5,
                      self.text6,
                      self.text7,
                      self.text8]

        self.cellChanges = (self.cellChange0,
                            self.cellChange1,
                            self.cellChange2,
                            self.cellChange3,
                            self.cellChange4,
                            self.cellChange5,
                            self.cellChange6,
                            self.cellChange7,
                            self.cellChangeLast)

        self.textChanges = (self.textChange0,
                            self.textChange1,
                            self.textChange2,
                            self.textChange3,
                            self.textChange4,
                            self.textChange5,
                            self.textChange6,
                            self.textChange7,
                            self.textChangeLast)

        Frame(self.window, width=3).grid(row=0, column=1)
        Label(self.window, text="Cell").grid(row=0, column=2)
        Frame(self.window, width=3).grid(row=0, column=3)
        Label(self.window, text="Text").grid(row=0, column=4)

        for neighbor in range(neighbors):
            self.labels[neighbor] = Label(self.window, text=str(neighbor), bg=colors[neighbor][0], fg=colors[neighbor][1], width=8)
            self.labels[neighbor].grid(row=2*neighbor+1, column=0)
            self.cells[neighbor] = Label(self.window, bg=colors[neighbor][0], width=3, bd=2)
            self.cells[neighbor].grid(row=2*neighbor+1, column=2)
            self.cells[neighbor].bind("<ButtonRelease-1>", self.cellChanges[neighbor])
            self.texts[neighbor] = Label(self.window, bg=colors[neighbor][1], width=3, bd=2)
            self.texts[neighbor].grid(row=2*neighbor+1, column=4)
            self.texts[neighbor].bind("<ButtonRelease-1>", self.textChanges[neighbor])
            Frame(self.window, height=3).grid(row=2*neighbor+2, column=0)

        self.labels[neighbors] = Label(self.window, text="{}+".format(str(neighbors)), bg=colors[-1][0], fg=colors[-1][1], width=8)
        self.labels[neighbors].grid(row=2*neighbors+1, column=0)
        self.cells[neighbors] = Label(self.window, bg=colors[-1][0], width=3, bd=2)
        self.cells[neighbors].grid(row=2*neighbors + 1, column=2)
        self.cells[neighbors].bind("<ButtonRelease-1>", self.cellChangeLast)
        self.texts[neighbors] = Label(self.window, bg=colors[-1][1], width=3, bd=2)
        self.texts[neighbors].grid(row=2*neighbors + 1, column=4)
        self.texts[neighbors].bind("<ButtonRelease-1>", self.textChangeLast)

        Button(self.window, text="OK", command=self.OK, width=8).grid(row=2*neighbors+2, column=0)
        Button(self.window, text="cancel", command=self.cancel, width=8).grid(row=2*neighbors+2, column=2, columnspan=3)

        parent.wait_window(self.window)

    def OK(self, event=None):
        self.colors = self.values
        self.cancel()

    def cancel(self, event=None):
        self.window.destroy()

    def get(self):
        return self.colors

    def cellChange0(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[0][0], parent=self.window)[1]
        self.labels[0].config(bg=color)
        self.cells[0].config(bg=color)
        self.values[0][0] = color

    def textChange0(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[0][1], parent=self.window)[1]
        self.labels[0].config(fg=color)
        self.texts[0].config(bg=color)
        self.values[0][1] = color

    def cellChange1(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[1][0], parent=self.window)[1]
        self.labels[1].config(bg=color)
        self.cells[1].config(bg=color)
        self.values[1][0] = color

    def textChange1(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[1][1], parent=self.window)[1]
        self.labels[1].config(fg=color)
        self.texts[1].config(bg=color)
        self.values[1][1] = color

    def cellChange2(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[2][0], parent=self.window)[1]
        self.labels[2].config(bg=color)
        self.cells[2].config(bg=color)
        self.values[2][0] = color

    def textChange2(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[2][1], parent=self.window)[1]
        self.labels[2].config(fg=color)
        self.texts[2].config(bg=color)
        self.values[2][1] = color

    def cellChange3(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[3][0], parent=self.window)[1]
        self.labels[3].config(bg=color)
        self.cells[3].config(bg=color)
        self.values[3][0] = color

    def textChange3(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[3][1], parent=self.window)[1]
        self.labels[3].config(fg=color)
        self.texts[3].config(bg=color)
        self.values[3][1] = color

    def cellChange4(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[4][0], parent=self.window)[1]
        self.labels[4].config(bg=color)
        self.cells[4].config(bg=color)
        self.values[4][0] = color

    def textChange4(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[4][1], parent=self.window)[1]
        self.labels[4].config(fg=color)
        self.texts[4].config(bg=color)
        self.values[4][1] = color

    def cellChange5(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[5][0], parent=self.window)[1]
        self.labels[5].config(bg=color)
        self.cells[5].config(bg=color)
        self.values[5][0] = color

    def textChange5(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[5][1], parent=self.window)[1]
        self.labels[5].config(fg=color)
        self.texts[5].config(bg=color)
        self.values[5][1] = color

    def cellChange6(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[6][0], parent=self.window)[1]
        self.labels[6].config(bg=color)
        self.cells[6].config(bg=color)
        self.values[6][0] = color

    def textChange6(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[6][1], parent=self.window)[1]
        self.labels[6].config(fg=color)
        self.texts[6].config(bg=color)
        self.values[6][1] = color

    def cellChange7(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[7][0], parent=self.window)[1]
        self.labels[7].config(bg=color)
        self.cells[7].config(bg=color)
        self.values[7][0] = color

    def textChange7(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[7][1], parent=self.window)[1]
        self.labels[7].config(fg=color)
        self.texts[7].config(bg=color)
        self.values[7][1] = color

    def cellChangeLast(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[7][0], parent=self.window)[1]
        self.labels[self.neighbors].config(bg=color)
        self.cells[self.neighbors].config(bg=color)
        self.values[-1][0] = color

    def textChangeLast(self, event=None):
        color = tkcolorpicker.askcolor(color=self.values[7][1], parent=self.window)[1]
        self.labels[self.neighbors].config(fg=color)
        self.texts[self.neighbors].config(bg=color)
        self.values[-1][1] = color


class ShapeSetter:
    def __init__(self, parent, shape, width, height, size):
        self.window = Toplevel(parent)
        self.window.title("Create New Grid")
        self.window.bind("<Escape>", self.cancel)

        self.shape = shape
        self.width = width
        self.height = height
        self.size = size
        self.values = None
        self.shapes = (("Square (Von Neumann)", "square"), ("Square (Moore)", "moore"), ("Hexagon", "hex"),
                       ("Triangle (Equilateral)", "tri"), ("Triangle (Right)", "right"))

        self.shapeLst = Listbox(self.window, height=9, selectmode=SINGLE)
        self.shapeLst.grid(column=0, row=0)
        for shape in self.shapes:
            self.shapeLst.insert(END, shape[0])
        indx = 0
        for shape in self.shapes:
            if shape[1] == self.shape:
                break
            else:
                indx += 1
        self.shapeLst.select_set(indx)

        self.menuFrame = Frame(self.window, height=120, width=30)
        self.menuFrame.grid(column=1, row=0)
        Label(self.menuFrame, text="Width").pack(side=TOP, anchor=W)
        self.widthVar = IntVar()
        self.widthVar.set(self.width)
        Entry(self.menuFrame, textvariable=self.widthVar).pack(side=TOP, fill=X)
        Label(self.menuFrame, text="Height").pack(side=TOP, anchor=W)
        self.heightVar = IntVar()
        self.heightVar.set(self.height)
        Entry(self.menuFrame, textvariable=self.heightVar).pack(side=TOP, fill=X)
        Label(self.menuFrame, text="Cellsize").pack(side=TOP, anchor=W)
        self.sizeVar = IntVar()
        self.sizeVar.set(self.size)
        Entry(self.menuFrame, textvariable=self.sizeVar).pack(side=TOP, fill=X)

        buttonFrame = Frame(self.window, height=25, width=180)
        buttonFrame.grid(row=1, column=0, columnspan=2)
        buttonFrame.grid_propagate(0)
        Button(buttonFrame, text="OK", width=8, command=self.OK).grid(column=0, row=0)
        Button(buttonFrame, text="cancel", width=8, command=self.cancel).grid(column=1, row=0)

        parent.wait_window(self.window)

    def cancel(self, event=None):
        self.window.destroy()

    def OK(self, event=None):
        shape = self.shapeLst.curselection()[0]
        self.shape = self.shapes[shape][1]
        self.width = self.widthVar.get()
        self.height = self.heightVar.get()
        self.size = self.sizeVar.get()
        self.values = (self.shape, self.width, self.height, self.size)
        self.window.destroy()

    def get(self):
        return self.values



test = Sandpile(1000, 1000)
